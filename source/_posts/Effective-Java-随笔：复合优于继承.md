---
title: Effective Java 随笔：复合优于继承
tags: Java
categories: 程序随记
comments: true
abbrlink: 84d15982
date: 2017-10-07 23:25:09
copyright: true
---
**第16条：复合优于继承**　　
　　只有当子类真正是超类的子类型（subtype）时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在“is-a”关系的时候，类B才应该扩展类A。如果你打算让类B扩展类A，就应该问问之间：每个B确实也是A吗？如果你不能确定这个问题的答案是肯定的，那么B就不应该扩展A。如果答案是否定的，通常情况下，B应该包含A的一个私有实例，并且暴露一个较小的、较简单的API：A本质上不是B的一部分，只是它的实现细节而已。

**第17条：要么为继承而设计，并提供文档说明，要么就禁止继承**
　　专门为继承而设计，就需要具有良好的文档说明。该类的文档必须精确地描述覆盖每个方法所带来的影响，换句话说，*该类必须有文档说明它可覆盖（overridable）的方法的自用性（self-use）*。
　　为了允许继承，类还必须遵守其他一些约束。*构造器决不能调用可被覆盖的方法*，无论是直接调用还是间接调用。如果违反了这条规则，很有可能导致程序失败。
　　如果你决定在一个为了继承而设计的类中实现了Cloneable或者Serializable接口，就应该意识到，因为clone和readObject方法在行为非常类似于构造器，所以类似的限制规则也是适合用的：无论是clone还是readObject，都不可以调用覆盖的方法，不管是以直接还是间接的方式。对于readObject方法，覆盖版本的方法将在子类的状态被反序列化之前被允许；而对于clone方法，覆盖版本的方法则是在子类的clone方法有机会修正被克隆对象中的状态之前被允许。无论哪种情形，都不可避免将导致程序失败。
