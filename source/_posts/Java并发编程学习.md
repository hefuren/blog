---
title: Java并发编程学习
tags:
  - Java
  - Java线程
categories: 程序随记
comments: true
abbrlink: 8f0f2355
date: 2017-10-08 11:18:10
copyright: true
---
> **不可变对象**可以在没有额外同步的情况下，安全地用于任意线程；甚至发布它们时亦不需要同步。

**安全发布的模式：**
如果一个对象是可变的，它就必须被安全地发布，通常发布线程与消费线程都必须同步化。如何确保消费线程能够看到处于发布当时的对象状态，我们要解决对象发布后对其修改的可见性问题。
> 为了安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确创建的对象可以通过下列条件安全地发布：
- 通过静态初始化器初始化对象的引用；
- 将它的引用存储到 volatile域或 AtomicReference；
- 将它的引用存储到正确创建的对象的final域中；
- 或者将它的引用存储到由锁正确保护的域中。

线程安全库中的容器提供了如下的线程安全保证：
-  置入Hashtable、synchronizedMap、ConcurrentMap 中的主键以及健值，会安全地发布到可以从Map获得它们的任意线程中，无论是直接获得还是通过迭代器（iterator）获得：
- 置入vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或者synchronizedSet中的元素，会安全地发布到可以从容器中获得它的任意线程中。
- 置入BlockingQueue 或者 ConcurrentLinkedQueue 的元素，会安全地发布到可以从队列中获得它的任意线程中。

```
//静态初始化器示例：
public static Holder holder = new Holder(42);
```

发布对象的必要条件依赖于对象的可变性：
- 不可变对象可以通过任意机制发布；
- 高效不可变对象必须要安全发布；
- 可变对象必须要安全发布，同时必须要线程安全或者被锁保护。

**安全地共享对象**
在并发程序中，使用共享对象的一些最有效的策略如下：
- 线程限制：一个线程限制的对象，通过限制在现场中，而被线程独占，且只能被占有它的线程修改。
- 共享只读（share read-only）：一个共享的只读对象，在没有额外同步的情况下，可以被多个线程并发地访问，但是任何线程都不能修改它。共享只读对象包括可变对象与高效不可变对象。
- 共享线程安全（shared thread-safe）：一个线程安全的对象在内部进行同步，所以其他线程无须额外同步，就可以通过公共接口随意地访问它。
- 被守护的（Guarded）：一个被守护的对象只能通过特定的锁来访问。被守护的对象包括那些被线程安全对象封装的对象，和已知被特定的锁保护起来的已发布对象。

将数据封装在对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的 锁。
